## 投了70多家 笔面试60多次 中二学长的秋招面经
### author 
乘风破浪2019
### post-time 

编辑于  2019-04-18 10:29:41
### content 
<div class="post-topic-des nc-post-content">
 <p style="color: rgb(51,51,51);text-align: justify;">
  秋招的时候在牛客上看了很多别人的面经，很有帮助。现在把自己面试的一些经历写出来，希望能有所回馈。
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <br/>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <strong>
   <span style="color: rgb(255,76,0);">
    秋招那段时间
   </span>
  </strong>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <strong>
   <span style="color: rgb(0,0,0);">
    <br/>
   </span>
  </strong>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span>
   <strong>
    <span style="color: rgb(0,0,0);">
     我投过的简历：
    </span>
   </strong>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: center;">
  <img src="https://uploadfiles.nowcoder.com/files/20190416/262185763_1555408745691_640" style="width: 593.0px;height: auto;"/>
 </p>
 <p style="color: rgb(51,51,51);text-align: center;">
  <img src="https://uploadfiles.nowcoder.com/files/20190416/262185763_1555408745683_640" style="width: 593.0px;height: auto;"/>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <br/>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <br/>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <strong>
    <span>
     笔面试流程
    </span>
   </strong>
   <strong>
    <span>
     :
    </span>
   </strong>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: center;">
  <img src="https://uploadfiles.nowcoder.com/files/20190416/262185763_1555408745691_640" style="width: 593.0px;height: auto;"/>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <br/>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(255,76,0);">
   <strong>
    三类公司
   </strong>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <br/>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span>
   <strong>
    <span style="color: rgb(0,0,0);">
     在我的笔面试过程中，可以依据参与类型和难度把公司大概分为几种。
    </span>
   </strong>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   第一种是来学校进行招聘的公司。
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   这一种是量大，成功率高也相对容易的机会。
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   首先是量大，几乎每天都有不止一家企业在学校开宣讲会。而对应企业耗费不少人力物力肯定是希望带走不少学生的。而且既然来了你们学校，那么学历肯定不会是你的劣势的。所以这一类是机会最大的。
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span>
   <span style="color: rgb(0,0,0);">
    <span>
     我所在的是一个普通
    </span>
    <span>
     211
    </span>
    <span>
     大学，也并不以计算机见长。
    </span>
   </span>
   <span style="color: rgb(0,0,0);">
    所以一流大厂的研发岗很少有来我们学校招聘的。所以面试的难度也不太大，这一类笔面试机会是夯实基础，积攒信心的良好去处。也是我拿
   </span>
   <span style="color: rgb(0,0,0);">
    <span>
     offer
    </span>
    <span>
     最多的类型。
    </span>
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   第二种是知名非互联网大厂的软件岗位。
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span>
   <span style="color: rgb(0,0,0);">
    <span>
     比如一些大银行，中兴
    </span>
    <span>
     OV
    </span>
    <span>
     小米等著名企业。
    </span>
   </span>
   <span style="color: rgb(0,0,0);">
    这类企业名声在外，招聘也很规范化有不低的要求。但毕竟核心并非互联网与软件，这类公司在计算机与软件技术的实力上还是比不上一流互联网大厂的。所以笔面试难度相对一流互联网公司较为容易，一些国企更看重成绩与学校奖项，而对技术要求相对淡化。如果实力没有那么强大去顶尖互联网公司的话，这类公司也是很好的选择，大平台也有利于将来发展。
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   第三种就是真正的一流互联网大厂了。
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span>
   <span style="color: rgb(0,0,0);">
    <span>
     以
    </span>
    <span>
     BAT
    </span>
    <span>
     ，字节跳动，网易等为代表，部分知名外企为辅助，以及一些在特定子领域技术实力较强的创业公司提供更多选择与机会。
    </span>
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   这一类企业是有志在互联网与将来的人工智能领域有所斩获的同学的主战场。简单说也就是大佬们挥洒的地方。也是笔面试难度最大的地方，同时也是对将来发展最有利的去处。
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(255,76,0);">
   <strong>
    面经（Java开发）
   </strong>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   下面把我的秋招过程总结的面试提问频率最高的一些内容分享给大家。很多的公司面试都大同小异，集中在这些部分。不同的是实力要求更高的公司问的更细更深，对算法的考察也更多。
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <br/>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <strong>
   <span style="color: rgb(255,76,0);">
    Java基础
   </span>
  </strong>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    super
   </span>
   <span>
    与
   </span>
   <span>
    this
   </span>
   <span>
    异同
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    1.
   </span>
   <span>
    作为引用，
   </span>
   <span>
    this
   </span>
   <span>
    表示当前对象，可在形参与对象属性重名时以示区分，
   </span>
   <span>
    super
   </span>
   <span>
    表示父类对象的引用
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
  </span>
  <span style="color: rgb(0,0,0);">
   <span>
    2.
   </span>
   <span>
    构造函数
   </span>
   <span>
    super(),this()
   </span>
   <span>
    表示调用构造方法。
   </span>
  </span>
  <span style="color: rgb(0,0,0);">
   <span>
    this()
   </span>
   <span>
    调用本类其他构造方法
   </span>
   <span>
    ,super()
   </span>
   <span>
    调用父类构造方法
   </span>
   <span>
    .
   </span>
   <span>
    其都要放在构造方法内第一行，所以两者不可能同时出现。
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
  </span>
  <span style="color: rgb(0,0,0);">
   <span>
    3.
   </span>
   <span>
    如未说明
   </span>
   <span>
    ,
   </span>
   <span>
    会默认在子类构造方法第一行加
   </span>
   <span>
    super(),
   </span>
   <span>
    但是如果父类没有无参构造方法，则必须显式声明。
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
  </span>
  <span style="color: rgb(0,0,0);">
   <span>
    4.
   </span>
   <span>
    本质上讲
   </span>
   <span>
    ,this
   </span>
   <span>
    是对本对象的引用，
   </span>
   <span>
    super
   </span>
   <span>
    是一个
   </span>
   <span>
    java
   </span>
   <span>
    关键字
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   异常:
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    异常分为
   </span>
   <span>
    Error
   </span>
   <span>
    和
   </span>
   <span>
    Exception
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    Error
   </span>
   <span>
    为编译和系统错误
   </span>
   <span>
    <span>
    </span>
   </span>
   <span>
    不允许被捕获
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    Exception
   </span>
   <span>
    又分为
   </span>
   <span>
    Runtime_Exception(
   </span>
   <span>
    运行时异常
   </span>
   <span>
    )
   </span>
   <span>
    和
   </span>
   <span>
    Non_RuntimeException(
   </span>
   <span>
    非运行时异常
   </span>
   <span>
    /
   </span>
   <span>
    可检测异常
   </span>
   <span>
    )
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <br/>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    常见的运行时异常
   </span>
   <span>
    :
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   indexsOutofBoundsException
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   SQLException
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   MemException
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   ArithmeticExecption
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   NumberFormatException
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   IOException
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    设计模式
   </span>
   <span>
    :
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   单例模式
  </span>
  <span style="color: rgb(0,0,0);">
   :
  </span>
  <span style="color: rgb(0,0,0);">
   <span>
    将该类的构造方法声明为
   </span>
   <span>
    private
   </span>
   <span>
    ，使得无法从外部类来实例化对象。
   </span>
  </span>
  <span style="color: rgb(0,0,0);">
   然后在类内部的方法中返回实例化的单一对象
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   工厂模式
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    备忘录模式
   </span>
   <span>
    :
   </span>
  </span>
  <span style="color: rgb(0,0,0);">
   <span>
    游戏当中进度存取
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   中介者模式
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    内存泄漏
   </span>
   <span>
    ---
   </span>
   <span>
    对象不再使用，无法被正常回收而驻留在堆内存中。
   </span>
  </span>
  <span style="color: rgb(0,0,0);">
   内存泄漏最终可能会导致内存溢出
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    1
   </span>
   <span>
    单例造成的内存泄漏
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    2
   </span>
   <span>
    线程造成的内存泄漏
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    3
   </span>
   <span>
    资源未关闭造成的内存泄漏
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    抽象类与接口的区别
   </span>
   <span>
    :
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    1
   </span>
   <span>
    抽象类可以有默认的方法实现，接口的方法不能实现
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    2
   </span>
   <span>
    继承抽象类使用
   </span>
   <span>
    extends,
   </span>
   <span>
    实现接口使用
   </span>
   <span>
    implements
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    3
   </span>
   <span>
    抽象类可以声明为
   </span>
   <span>
    public,protected,default
   </span>
   <span>
    。
   </span>
  </span>
  <span style="color: rgb(0,0,0);">
   接口只能声明为
  </span>
  <span style="color: rgb(0,0,0);">
   public
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    4
   </span>
   <span>
    抽象类可以有构造器，接口不能有构造器
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <br/>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <strong>
   <span style="color: rgb(255,76,0);">
    Java集合
   </span>
  </strong>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    HashMap
   </span>
   <span>
    与
   </span>
   <span>
    HashTable
   </span>
   <span>
    区别
   </span>
   <span>
    :
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   1:
  </span>
  <span style="color: rgb(0,0,0);">
   <span>
    父类不同
   </span>
   <span>
    <span>
    </span>
    HashMap
   </span>
   <span>
    父类为
   </span>
   <span>
    AbstractMap,HashTable
   </span>
   <span>
    父类为
   </span>
   <span>
    Dictionary
    <span>
     <span>
     </span>
    </span>
   </span>
   <span>
    但它们都实现了
   </span>
   <span>
    map cloneable serializabl
   </span>
   <span>
    三个接口
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   2:HashTable
  </span>
  <span style="color: rgb(0,0,0);">
   <span>
    不允许
   </span>
   <span>
    Null key
    <span>
    </span>
   </span>
   <span>
    与
   </span>
   <span>
    <span>
    </span>
    null value
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   3:hashtable
  </span>
  <span style="color: rgb(0,0,0);">
   <span>
    是线程安全的
   </span>
   <span>
    <span>
     <span>
     </span>
    </span>
    hashmap
   </span>
   <span>
    不是线程安全的，在多线程情况下有可能产生死锁
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    解决
   </span>
   <span>
    hash
   </span>
   <span>
    冲突的四种方法
   </span>
   <span>
    :
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   开放定址发
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    链地址法
   </span>
   <span>
    <span>
     <span>
     </span>
    </span>
    hashmap
   </span>
   <span>
    采用的方法
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    再
   </span>
   <span>
    hash
   </span>
   <span>
    法
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   公共溢出区
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <br/>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   ArrayList与LinkedList的异同
  </span>
  <span style="color: rgb(0,0,0);">
   <br/>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <br/>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <strong>
   <span style="color: rgb(255,76,0);">
    JVM
   </span>
  </strong>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   堆内存与栈内存区别
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <br/>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   Java的垃圾回收
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    1
    <span>
    </span>
   </span>
   <span>
    判断对象是否存活，两种方法，可达性分析和引用计数
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    2 GC
   </span>
   <span>
    垃圾收集算法，
   </span>
   <span>
    4
   </span>
   <span>
    种，标记清除，复制，标记整理，分代收集
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    3 GC
   </span>
   <span>
    垃圾收集器，
   </span>
   <span>
    7
   </span>
   <span>
    种，对应垃圾回收算法来回答
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    4
    <span>
    </span>
   </span>
   <span>
    内存分配策略，
   </span>
   <span>
    5
   </span>
   <span>
    种
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <br/>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   类加载与双亲委派机制
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <br/>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <strong>
   <span style="color: rgb(255,76,0);">
    多线程
   </span>
  </strong>
  <span style="color: rgb(0,0,0);">
   <br/>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    start()
   </span>
   <span>
    与
   </span>
   <span>
    run()
   </span>
   <span>
    的区别
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    run
   </span>
   <span>
    只是
   </span>
   <span>
    thread
   </span>
   <span>
    中的一个普通方法，还是在主线程中中执行。
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    start
   </span>
   <span>
    是真正启动线程，实现了多线程运行
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    线程
   </span>
   <span>
    5
   </span>
   <span>
    种状态
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    创建状态
   </span>
   <span>
    <span>
    </span>
   </span>
   <span>
    生成线程对象之后，
   </span>
   <span>
    start
   </span>
   <span>
    之前
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    就绪状态
   </span>
   <span>
    <span>
     <span>
     </span>
    </span>
    start
   </span>
   <span>
    之后，运行之前。
   </span>
  </span>
  <span style="color: rgb(0,0,0);">
   或者从等待或睡眠中回来
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    运行状态
   </span>
   <span>
    <span>
     <span>
     </span>
    </span>
    CPU
   </span>
   <span>
    开始运行该线程
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    阻塞状态
   </span>
   <span>
    <span>
    </span>
   </span>
   <span>
    正在运行的时候被暂停，如等待某资源。
   </span>
  </span>
  <span style="color: rgb(0,0,0);">
   可使用
  </span>
  <span style="color: rgb(0,0,0);">
   <span>
    <span>
    </span>
    sleep,suspend,wait
   </span>
   <span>
    等方法使其阻塞
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    死亡状态
   </span>
   <span>
    <span>
     <span>
     </span>
    </span>
    run
   </span>
   <span>
    方法执行结束或者调用
   </span>
   <span>
    stop
   </span>
   <span>
    方法
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    wait()
   </span>
   <span>
    与
   </span>
   <span>
    sleep()
   </span>
   <span>
    的区别
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    sleep
   </span>
   <span>
    是
   </span>
   <span>
    Thread
   </span>
   <span>
    类中的方法，线程进入
   </span>
   <span>
    sleep
   </span>
   <span>
    状态，会暂停运行一段时间，把
   </span>
   <span>
    CPU
   </span>
   <span>
    让出，但不会释放锁资源以及监控的状态
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    wait
   </span>
   <span>
    是
   </span>
   <span>
    Obiect
   </span>
   <span>
    类中的方法，会使线程放弃当前对象的锁，只有针对该对象调用
   </span>
   <span>
    notify
   </span>
   <span>
    方法之后才能进入对象锁定池重新获取对象锁
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    如何安全地停止线程
   </span>
   <span>
    :
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    <span>
    </span>
   </span>
   <span>
    不能直接调用线程的
   </span>
   <span>
    stop
   </span>
   <span>
    方法，这样会导致无法进行必要的收尾操作及释放资源
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    <span>
    </span>
   </span>
   <span>
    调用线程的
   </span>
   <span>
    interrupt
   </span>
   <span>
    方法，为线程做上“需要终止”的标识
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    <span>
    </span>
   </span>
   <span>
    在线程内部每一次循环进行判断
   </span>
   <span>
    Thread.interrupted()
   </span>
   <span>
    来决定是否进行必要收尾后
   </span>
   <span>
    return,
   </span>
   <span>
    结束
   </span>
   <span>
    run
   </span>
   <span>
    方法体
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    多线程的实现方式
   </span>
   <span>
    :
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    1
   </span>
   <span>
    继承
   </span>
   <span>
    Thread
   </span>
   <span>
    类
   </span>
   <span>
    <span>
    </span>
   </span>
   <span>
    实例化之后调用
   </span>
   <span>
    start
   </span>
   <span>
    方法
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    2
   </span>
   <span>
    实现
   </span>
   <span>
    Runnable
   </span>
   <span>
    接口
   </span>
   <span>
    <span>
    </span>
   </span>
   <span>
    实例化一个
   </span>
   <span>
    Thread
   </span>
   <span>
    传入该类实例
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    3
   </span>
   <span>
    实现
   </span>
   <span>
    Callable
   </span>
   <span>
    接口，通过
   </span>
   <span>
    FutureTask
   </span>
   <span>
    包装器来创建线程
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    4
   </span>
   <span>
    使用
   </span>
   <span>
    ExecutorService
   </span>
   <span>
    、
   </span>
   <span>
    Callable
   </span>
   <span>
    、
   </span>
   <span>
    Future
   </span>
   <span>
    实现有返回结果的线程
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <br/>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    ExecutorService
   </span>
   <span>
    、
   </span>
   <span>
    Callable
   </span>
   <span>
    、
   </span>
   <span>
    Future
   </span>
   <span>
    三个接口实际上都是属于
   </span>
   <span>
    Executor
   </span>
   <span>
    框架。
   </span>
  </span>
  <span style="color: rgb(0,0,0);">
   返回结果的线程是在
  </span>
  <span style="color: rgb(0,0,0);">
   <span>
    JDK1.5
   </span>
   <span>
    中引入的新特征，有了这种特征就不需要再为了得到返回值而大费周折了。
   </span>
  </span>
  <span style="color: rgb(0,0,0);">
   而且自己实现了也可能漏洞百出。
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    可返回值的任务必须实现
   </span>
   <span>
    Callable
   </span>
   <span>
    接口。
   </span>
  </span>
  <span style="color: rgb(0,0,0);">
   类似的，无返回值的任务必须实现
  </span>
  <span style="color: rgb(0,0,0);">
   <span>
    Runnable
   </span>
   <span>
    接口。
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    执行
   </span>
   <span>
    Callable
   </span>
   <span>
    任务后，可以获取一个
   </span>
   <span>
    Future
   </span>
   <span>
    的对象，在该对象上调用
   </span>
   <span>
    get
   </span>
   <span>
    就可以获取到
   </span>
   <span>
    Callable
   </span>
   <span>
    任务返回的
   </span>
   <span>
    Object
   </span>
   <span>
    了。
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   注意：
  </span>
  <span style="color: rgb(0,0,0);">
   <span>
    get
   </span>
   <span>
    方法是阻塞的，即：
   </span>
  </span>
  <span style="color: rgb(0,0,0);">
   线程无返回结果，
  </span>
  <span style="color: rgb(0,0,0);">
   <span>
    get
   </span>
   <span>
    方***一直等待。
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    再结合线程池接口
   </span>
   <span>
    ExecutorService
   </span>
   <span>
    就可以实现传说中有返回结果的多线程了。
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    进程与线程的区别
   </span>
   <span>
    :
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   1:
  </span>
  <span style="color: rgb(0,0,0);">
   <span>
    进程是资源分配的最小单位，线程是
   </span>
   <span>
    CPU
   </span>
   <span>
    调度的最小单位
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   2:
  </span>
  <span style="color: rgb(0,0,0);">
   <span>
    进程有独立的地址空间，线程之间共享其进程的同一空间。
   </span>
  </span>
  <span style="color: rgb(0,0,0);">
   所以进程调度开销更大。
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   3:
  </span>
  <span style="color: rgb(0,0,0);">
   <span>
    线程之间由于共享资源，交流方便但会互相干涉。
   </span>
  </span>
  <span style="color: rgb(0,0,0);">
   而进程之间交流以通信的方式进行。
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <br/>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <strong>
   <span style="color: rgb(255,76,0);">
    大数据框架
   </span>
  </strong>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    hadoop
   </span>
   <span>
    离线数据处理框架
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    spark,storm
   </span>
   <span>
    实时数据处理框架
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <br/>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    hadoop
   </span>
   <span>
    的运行模式分
   </span>
   <span>
    3
   </span>
   <span>
    种
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    1.
   </span>
   <span>
    本地运行模式
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    2.
   </span>
   <span>
    伪分布式运行模式
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    3.
   </span>
   <span>
    分布式集群运行模式
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <br/>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    hadoop
   </span>
   <span>
    中通信
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    namenode
   </span>
   <span>
    通过
   </span>
   <span>
    rpc
   </span>
   <span>
    通信
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    client
   </span>
   <span>
    与
   </span>
   <span>
    datanode
   </span>
   <span>
    通过
   </span>
   <span>
    socket
   </span>
   <span>
    通信
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   hadoop HDFC(hadoop distribute file system)
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <br/>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    Spark
   </span>
   <span>
    有
   </span>
   <span>
    3
   </span>
   <span>
    种运行模式：
   </span>
  </span>
  <span style="color: rgb(0,0,0);">
   独立集群运行模式、
  </span>
  <span style="color: rgb(0,0,0);">
   <span>
    YARN
   </span>
   <span>
    运行模式、
   </span>
   <span>
    Mesos
   </span>
   <span>
    运行模式。
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <br/>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <br/>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <strong>
   <span style="color: rgb(255,76,0);">
    开发框架
   </span>
  </strong>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   Spring
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   ioc:
  </span>
  <span style="color: rgb(0,0,0);">
   <span>
    依赖注入，也叫控制反转
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   aop:
  </span>
  <span style="color: rgb(0,0,0);">
   <span>
    面向切面编程
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   Redis
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    redis
   </span>
   <span>
    五种数据结构
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   string hash list set zset
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    使用
   </span>
   <span>
    redis
   </span>
   <span>
    实现分布式
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    1
   </span>
   <span>
    读写分离模型
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    <span>
    </span>
   </span>
   <span>
    采取主从模式，
   </span>
   <span>
    master
   </span>
   <span>
    更新数据并将其同步到
   </span>
   <span>
    slave
   </span>
   <span>
    上，
   </span>
   <span>
    slave
   </span>
   <span>
    提供检索服务，
   </span>
   <span>
    master
   </span>
   <span>
    负责同步数据
   </span>
   <span>
    <span>
    </span>
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    2
   </span>
   <span>
    数据分片模型
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   Mem***d
   <span>
    <span>
    </span>
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    分布式内存对象缓存系统，通过缓存数据库查询结果，减少数据库访问，提高动态
   </span>
   <span>
    web
   </span>
   <span>
    速度，提高可扩展性
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    redis
   </span>
   <span>
    与
   </span>
   <span>
    Mem***d
   </span>
   <span>
    比较
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    1 redis
   </span>
   <span>
    不仅支持基础的
   </span>
   <span>
    key-value
   </span>
   <span>
    类型数据，还提供
   </span>
   <span>
    List,set,zset,hash
   </span>
   <span>
    等数据结构
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    2 redis
   </span>
   <span>
    提供数据备份，即主从模式的数据备份
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    3 redis
   </span>
   <span>
    支持数据持久化，可以将数据保存进磁盘。
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <br/>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    redis
   </span>
   <span>
    数据结构应用场景
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    1 List
    <span>
     <span>
     </span>
    </span>
   </span>
   <span>
    消息队列
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    2 Hash
    <span>
     <span>
     </span>
    </span>
   </span>
   <span>
    实际上
   </span>
   <span>
    value
   </span>
   <span>
    是一个
   </span>
   <span>
    HashMap,
   </span>
   <span>
    可以存放比如一个用户的各种信息
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    3 Set
    <span>
     <span>
     </span>
    </span>
   </span>
   <span>
    可以实现关注功能
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <br/>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <strong>
   <span style="color: rgb(255,76,0);">
    数据库
   </span>
  </strong>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    char
   </span>
   <span>
    与
   </span>
   <span>
    varchar
   </span>
  </span>
  <span style="color: rgb(0,0,0);">
   的区别
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    事务的四大特性
   </span>
   <span>
    :
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    <span>
    </span>
   </span>
   <span>
    原子性
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    <span>
    </span>
   </span>
   <span>
    一致性
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    <span>
    </span>
   </span>
   <span>
    隔离性
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    <span>
    </span>
   </span>
   <span>
    永久性
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    事务并发时的
   </span>
   <span>
    3
   </span>
   <span>
    种问题
   </span>
   <span>
    :
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    <span>
    </span>
   </span>
   <span>
    脏读
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    <span>
    </span>
   </span>
   <span>
    不可重复读
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    <span>
    </span>
   </span>
   <span>
    幻读
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    隔离的四种级别
   </span>
   <span>
    :
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    <span>
    </span>
   </span>
   <span>
    串行化
   </span>
   <span>
    :
   </span>
  </span>
  <span style="color: rgb(0,0,0);">
   <span>
    最高级别
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    <span>
    </span>
   </span>
   <span>
    可重复读
   </span>
   <span>
    :
   </span>
  </span>
  <span style="color: rgb(0,0,0);">
   <span>
    避免脏读和不可重复读
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    <span>
    </span>
   </span>
   <span>
    读已提交
   </span>
   <span>
    :
   </span>
  </span>
  <span style="color: rgb(0,0,0);">
   <span>
    避免脏读
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    <span>
    </span>
   </span>
   <span>
    读未提交
   </span>
   <span>
    :
   </span>
  </span>
  <span style="color: rgb(0,0,0);">
   <span>
    最低级别，无法保证
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    常用查询优化
   </span>
   <span>
    :
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    1
   </span>
   <span>
    避免在
   </span>
   <span>
    where
   </span>
   <span>
    子句上进行
   </span>
   <span>
    null
   </span>
   <span>
    值判断
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    2
   </span>
   <span>
    慎用
   </span>
   <span>
    in
   </span>
   <span>
    与
   </span>
   <span>
    not in
    <span>
     <span>
     </span>
    </span>
   </span>
   <span>
    能用
   </span>
   <span>
    between
   </span>
   <span>
    就不要用
   </span>
   <span>
    in
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    3
   </span>
   <span>
    避免在
   </span>
   <span>
    where
   </span>
   <span>
    字句对
   </span>
   <span>
    <span>
    </span>
    =
    <span>
    </span>
   </span>
   <span>
    左边进行表达式或函数操作
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    4
   </span>
   <span>
    组合索引情况下，必须使用到索引的第一个字段才能使索引生效，并且尽可能使字段顺序与索引顺序一致
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    5
   </span>
   <span>
    要注意索引并不是越多越好，索引可以提高查询效率但是会降低更改表的效率，并且也会占用存储空间，所以要视情况而定
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
  </span>
  <span style="color: rgb(0,0,0);">
   <span>
    可以使用
   </span>
   <span>
    explain
    <span>
    </span>
   </span>
   <span>
    语句来解析
   </span>
   <span>
    sql
   </span>
   <span>
    方便制定优化方案
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    数据库索引，
   </span>
   <span>
    B+
   </span>
   <span>
    树，为什么用
   </span>
   <span>
    B+
   </span>
   <span>
    树
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   常用数据库引擎
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   ISAM
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    MyISAM
    <span>
     <span>
     </span>
    </span>
    ISAM
   </span>
   <span>
    在索引与事务上的扩展
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    HEAP
    <span>
     <span>
     </span>
    </span>
   </span>
   <span>
    支持只驻留在内存中的临时表格
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    InnoDB
    <span>
     <span>
     </span>
    </span>
   </span>
   <span>
    支持
   </span>
   <span>
    MySql++ API
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <br/>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <br/>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <strong>
   <span style="color: rgb(255,76,0);">
    计算机网络
   </span>
  </strong>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   tcp:
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   面向连接，是可靠的
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   保证按序到达
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    全双工协议
   </span>
   <span>
    <span>
    </span>
   </span>
   <span>
    允许在两个方向上同时传输
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    活动窗口及拥塞控制
   </span>
   <span>
    :
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    发送窗口
   </span>
   <span>
    :
   </span>
  </span>
  <span style="color: rgb(0,0,0);">
   <span>
   </span>
  </span>
  <span style="color: rgb(0,0,0);">
   建立连接时发送者被告知接收者接收窗口大小，以此来决定发送窗口大小
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    拥塞控制
   </span>
   <span>
    :
   </span>
  </span>
  <span style="color: rgb(0,0,0);">
   <span>
   </span>
  </span>
  <span style="color: rgb(0,0,0);">
   <span>
    慢开始，快重传
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <br/>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    http
   </span>
   <span>
    ：
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    http
   </span>
   <span>
    状态码
   </span>
   <span>
    :
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    200
   </span>
   <span>
    成功
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    3XX
   </span>
   <span>
    重定向
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    4XX
   </span>
   <span>
    请求错误
   </span>
   <span>
    <span>
     <span>
     </span>
    </span>
    400
   </span>
   <span>
    请求格式错误
   </span>
   <span>
    <span>
    </span>
    401
   </span>
   <span>
    未授权
   </span>
   <span>
    <span>
    </span>
    403
   </span>
   <span>
    禁止
   </span>
   <span>
    <span>
    </span>
    404
   </span>
   <span>
    未找到
   </span>
   <span>
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    5XX
   </span>
   <span>
    服务器内部错误
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    http get
   </span>
   <span>
    与
   </span>
   <span>
    post
   </span>
   <span>
    区别
   </span>
   <span>
    :
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    get
   </span>
   <span>
    明文传输，数据显示在
   </span>
   <span>
    url
   </span>
   <span>
    中
   </span>
   <span>
    <span>
     ，
    </span>
    post
   </span>
   <span>
    数据不显示在
   </span>
   <span>
    url
   </span>
   <span>
    中
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    get
   </span>
   <span>
    安全性更差，发送敏感信息不应使用
   </span>
   <span>
    get
    <span>
     <span>
     </span>
     ，
    </span>
    post
   </span>
   <span>
    更安全，信息不会被保存到浏览器历史或服务器日志中
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    get
   </span>
   <span>
    有传输长度限制
   </span>
   <span>
    <span>
     ，
    </span>
    post
   </span>
   <span>
    无传输长度限制
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    get
   </span>
   <span>
    只允许
   </span>
   <span>
    ASCII
   </span>
   <span>
    字符
   </span>
   <span>
    <span>
     ，
    </span>
    post
   </span>
   <span>
    不仅允许
   </span>
   <span>
    ASCII
   </span>
   <span>
    ，也允许二进制数据
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <br/>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <strong>
   <span style="color: rgb(255,76,0);">
    Linux
   </span>
  </strong>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    模糊查询
   </span>
   <span>
    <span>
     <span>
     </span>
    </span>
    find -name
    <span>
     <span>
     </span>
    </span>
    "*abc"
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    查看进程信息
   </span>
   <span>
    <span>
     <span>
     </span>
    </span>
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    top
    <span>
     <span>
     </span>
     <span>
     </span>
    </span>
    top
   </span>
   <span>
    中内容可动态更新，而且可进行其他操作
   </span>
   <span>
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    ps -aux
    <span>
     <span>
     </span>
     <span>
     </span>
    </span>
    ps
   </span>
   <span>
    只显示静态内容
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    可同时利用
   </span>
   <span>
    grep
   </span>
   <span>
    抓取我们想要获取的内容，
   </span>
   <span>
    某进程的
   </span>
   <span>
    cwd
   </span>
   <span>
    内容是该进程的文件所在位置
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <br/>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    查看
   </span>
   <span>
    cpu
    <span>
     <span>
     </span>
     <span>
     </span>
    </span>
    cat /proc/cpuinfo
    <span>
     <span>
     </span>
    </span>
   </span>
   <span>
    查看内存信息
   </span>
   <span>
    <span>
     <span>
     </span>
    </span>
    cat
    <span>
    </span>
    /proc/meminfo
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    查看端口
   </span>
   <span>
    netstat
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <br/>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    wc
   </span>
   <span>
    命令
   </span>
   <span>
    <span>
    </span>
   </span>
   <span>
    查看文件有多少行
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <br/>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    mount
    <span>
    </span>
   </span>
   <span>
    挂载
   </span>
   <span>
    linux
   </span>
   <span>
    系统外文件
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <br/>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    strace Linux
   </span>
   <span>
    调试分析诊断工具
   </span>
   <span>
    ,
   </span>
   <span>
    跟踪进程的系统调用等相关信息
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    进程间通信
   </span>
   <span>
    5
   </span>
   <span>
    种方式
   </span>
   <span>
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    管道
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   FIFO
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    消息队列
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    信号量
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(0,0,0);">
   <span>
    共享内存
   </span>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <br/>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <span style="color: rgb(255,76,0);">
   <strong>
    结语
   </strong>
  </span>
 </p>
 <p style="color: rgb(51,51,51);text-align: justify;">
  <br/>
 </p>
 <div style="color: rgb(51,51,51);text-align: justify;">
  我的能力不算突出，大家从我笔面试的经历也可以看出来，真正的顶级大厂我是一个offer都没有拿到的。但是好在我投的面的都比较多，各种公司的笔面试也都经历见识过，通过此文分享出来，希望可以给大家带来一定的帮助，也希望准备迈向春招秋招大坑的学弟学妹们可以乘风破浪，勇往直前，开心地离开校园，昂首进入公司！
 </div>
 <div style="color: rgb(51,51,51);text-align: justify;">
  <br/>
 </div>
 <div style="color: rgb(51,51,51);text-align: justify;">
  <br/>
 </div>
 <div style="color: rgb(51,51,51);text-align: justify;">
  <br/>
 </div>
 <div style="color: rgb(51,51,51);text-align: justify;">
  另外推荐一个公众号，学习技术与算法可以关注一下哈
 </div>
 <div style="color: rgb(51,51,51);text-align: justify;">
  算法面试题
 </div>
 <div style="color: rgb(51,51,51);text-align: justify;">
  <img alt="" src="https://uploadfiles.nowcoder.com/images/20190416/262185763_1555408820899_26A4ED3FFA26F3CBD2E710D4C233E938"/>
  <br/>
 </div>
 <div style="color: rgb(51,51,51);text-align: justify;">
  <br/>
 </div>
</div>
